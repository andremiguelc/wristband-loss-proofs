import WristbandLossProofs.ImportedFacts

set_option autoImplicit false

noncomputable section

namespace WristbandLossProofs

open MeasureTheory

/-! ## Wristband Construction Primitives -/

/-- The wristband map `Φ(z) = (direction(z), CDF(radiusSq(z)))`. -/
def wristbandMap (d : ℕ) (z : VecNZ d) : Wristband d :=
  (direction (d := d) z, chiSqCDFToUnit d (radiusSq z))

/-- Pushforward wristband law `P_Q = Φ_#Q`. -/
def wristbandLaw (d : ℕ) (Q : Distribution (VecNZ d)) : Distribution (Wristband d) :=
  pushforward (wristbandMap d) Q

/-! ## Spherical Law Determined by Radius Skeleton -/

/--
Reconstruct a vector from `(squared radius, direction)` by
`(s, u) ↦ √s • u`.
-/
def radialReconstruct (d : ℕ) : NNReal × Sphere d → Vec d
  | (s, u) => (Real.sqrt (s : ℝ)) • u.1

/--
Law generated by:
1. sample squared radius from `radiusSqLaw`,
2. sample direction uniformly from the sphere,
3. set `Z = √S • U`.
-/
def sphericalLaw (d : ℕ) (radiusSqLaw : Distribution NNReal) : Distribution (Vec d) :=
  pushforward (radialReconstruct d) (productLaw radiusSqLaw (sphereUniform d))

/-- Rotation-invariance predicate for laws on `ℝ^d`. -/
def IsRotationInvariant (d : ℕ) (μ : Distribution (Vec d)) : Prop :=
  ∀ O : (Vec d) ≃ₗᵢ[ℝ] Vec d, pushforward (fun z => O z) μ = μ

/--
**Lemma (Spherical law, rotation-invariance part):**
spherical construction is rotation-invariant.

Technical note: this formal proof uses `SFinite` assumptions so that
Mathlib's product-measure transport lemmas (`Measure.map_prod_map`) apply.
-/
theorem sphericalLaw_rotationInvariant
    (d : ℕ)
    (radiusSqLaw : Distribution NNReal)
    [SFinite radiusSqLaw]
    [SFinite (sphereUniform d)] :
    IsRotationInvariant d (sphericalLaw d radiusSqLaw) := by
  intro O
  unfold sphericalLaw pushforward productLaw
  -- Step 1: establish measurability of every map that appears in `map_map` rewrites.
  have hMeasO : Measurable (fun z : Vec d => O z) := O.continuous.measurable
  have hMeasRadialReconstruct : Measurable (radialReconstruct d) := by
    change Measurable (fun p : NNReal × Sphere d => Real.sqrt (p.1 : ℝ) • p.2.1)
    exact (Real.continuous_sqrt.measurable.comp
      (measurable_coe_nnreal_real.comp measurable_fst)).smul
      (measurable_subtype_coe.comp measurable_snd)
  have hMeasRotateSphere : Measurable (rotateSphere O) := by
    unfold rotateSphere
    refine Measurable.subtype_mk ?_
    simpa [Function.comp] using
      (O.continuous.comp continuous_subtype_val).measurable
  have hMeasRotateProd :
      Measurable (Prod.map id (rotateSphere O) : NNReal × Sphere d → NNReal × Sphere d) :=
    measurable_id.prodMap hMeasRotateSphere
  -- Step 2: pointwise algebra. Rotating `√s • u` equals reconstructing from `(s, O u)`.
  have hPointwiseCommute :
      ((fun z : Vec d => O z) ∘ radialReconstruct d) =
        radialReconstruct d ∘ Prod.map id (rotateSphere O) := by
    funext p
    rcases p with ⟨r, u⟩
    simp [radialReconstruct, rotateSphere, Function.comp]
  -- Step 3: transport the product law through `Prod.map id (rotateSphere O)`.
  -- The first coordinate is unchanged, and the second one is invariant by imported axiom.
  have hProdMap :
      Measure.map (Prod.map id (rotateSphere O)) (radiusSqLaw.prod (sphereUniform d)) =
        radiusSqLaw.prod (sphereUniform d) := by
    calc
      Measure.map (Prod.map id (rotateSphere O)) (radiusSqLaw.prod (sphereUniform d))
          = (Measure.map id radiusSqLaw).prod (Measure.map (rotateSphere O) (sphereUniform d)) := by
              symm
              exact Measure.map_prod_map radiusSqLaw (sphereUniform d)
                measurable_id hMeasRotateSphere
      _ = radiusSqLaw.prod (Measure.map (rotateSphere O) (sphereUniform d)) := by
            simp [Measure.map_id]
      _ = radiusSqLaw.prod (sphereUniform d) := by
            simpa [pushforward] using congrArg (fun μ => radiusSqLaw.prod μ)
              (sphereUniform_rotationInvariant d O)
  -- Step 4: chain the previous identities into equality of pushforward laws.
  calc
    Measure.map (fun z : Vec d => O z)
        (Measure.map (radialReconstruct d) (radiusSqLaw.prod (sphereUniform d)))
        = Measure.map ((fun z : Vec d => O z) ∘ radialReconstruct d)
            (radiusSqLaw.prod (sphereUniform d)) := by
            rw [Measure.map_map hMeasO hMeasRadialReconstruct]
    _ = Measure.map (radialReconstruct d ∘ Prod.map id (rotateSphere O))
          (radiusSqLaw.prod (sphereUniform d)) := by
            rw [hPointwiseCommute]
    _ = Measure.map (radialReconstruct d)
          (Measure.map (Prod.map id (rotateSphere O)) (radiusSqLaw.prod (sphereUniform d))) := by
            rw [← Measure.map_map hMeasRadialReconstruct hMeasRotateProd]
    _ = Measure.map (radialReconstruct d) (radiusSqLaw.prod (sphereUniform d)) := by
            rw [hProdMap]

/--
**Lemma (header-level identification by squared-radius law).**

If `U` is uniform on the sphere, independent of nonnegative squared-radius variable `S`,
then the law of `Z = √S • U` is exactly the spherical law built from `S`'s law.

This is the theorem-shape needed in the proof plan; proof is deferred for now.
-/
theorem sphericalLaw_determinedByRadius
    (d : ℕ)
    {Ω : Type _}
    [MeasurableSpace Ω]
    (μ : Distribution Ω)
    [IsProbabilityMeasure μ]
    (S : Ω → NNReal)
    (U : Ω → Sphere d)
    (hU : pushforward U μ = sphereUniform d)
    (hIndep : IndepLaw μ S U) :
    pushforward (fun ω => (Real.sqrt (S ω : ℝ)) • (U ω).1) μ =
      sphericalLaw d (pushforward S μ) := by
  -- Deferred: this is the identification theorem required by the proof plan.
  sorry

/-! ## Wristband Equivalence Skeleton -/

/--
**Theorem (Wristband equivalence, forward direction: `Q = γ → P_Q = μ₀`).**

Roadmap:
1. Use Gaussian polar decomposition (imported package).
2. Apply Probability Integral Transform (PIT) to the chi-square radius.
3. Transfer independence through the CDF map.
4. Identify the wristband law as `wristbandUniform`.
-/
theorem wristbandEquivalence_forward (d : ℕ) :
    wristbandLaw d (gaussianNZ d) = wristbandUniform d := by
  -- Deferred until PIT + independence lemmas are concretized.
  sorry

/--
**Theorem (Wristband equivalence, backward direction: `P_Q = μ₀ → Q = γ`).**

Roadmap:
1. Read off uniform marginals and independence from `P_Q = μ₀`.
2. Use reverse PIT to recover the chi-square radius law.
3. Apply Spherical law determined by radius lemma.
4. Match Gaussian polar data and conclude `Q = γ`.
-/
theorem wristbandEquivalence_backward
    (d : ℕ)
    (Q : Distribution (VecNZ d))
    [IsProbabilityMeasure Q]
    (hUniform : wristbandLaw d Q = wristbandUniform d) :
    Q = gaussianNZ d := by
  -- Deferred until PIT reverse direction is implemented concretely.
  sorry

/--
**Theorem (full equivalence).**

This is the core logical bridge used later by kernel/energy minimization results.
-/
theorem wristbandEquivalence
    (d : ℕ)
    (Q : Distribution (VecNZ d))
    [IsProbabilityMeasure Q] :
    wristbandLaw d Q = wristbandUniform d ↔ Q = gaussianNZ d := by
  constructor
  · intro hUniform
    exact wristbandEquivalence_backward d Q hUniform
  · intro hGaussian
    simpa [hGaussian] using wristbandEquivalence_forward d

end WristbandLossProofs
