import WristbandLossProofs.ImportedFacts

set_option autoImplicit false

noncomputable section

namespace WristbandLossProofs

open MeasureTheory

/-! ## Wristband Construction Primitives -/

/-- The wristband map `Φ(z) = (direction(z), CDF(radiusSq(z)))`. -/
def wristbandMap (d : ℕ) (z : VecNZ d) : Wristband d :=
  (direction (d := d) z, chiSqCDFToUnit d (radiusSq z))

/-- Measurability of the wristband map. -/
lemma measurable_wristbandMap (d : ℕ) : Measurable (wristbandMap d) := by
  refine (measurable_direction d).prodMk ?_
  exact (chiSqCDFToUnit_measurable d).comp (measurable_radiusSq d)

/-- Pushforward wristband law `P_Q = Φ_#Q`. -/
def wristbandLaw (d : ℕ) (Q : Distribution (VecNZ d)) : Distribution (Wristband d) :=
  pushforward (wristbandMap d) Q (measurable_wristbandMap d)

/-! ## Spherical Law Determined by Radius Skeleton -/

/--
Reconstruct a vector from `(squared radius, direction)` by
`(s, u) ↦ √s • u`.
-/
def radialReconstruct (d : ℕ) : NNReal × Sphere d → Vec d
  | (s, u) => (Real.sqrt (s : ℝ)) • u.1

/-- Measurability of the radial reconstruction map. -/
lemma measurable_radialReconstruct (d : ℕ) : Measurable (radialReconstruct d) := by
  change Measurable (fun p : NNReal × Sphere d => Real.sqrt (p.1 : ℝ) • p.2.1)
  exact (Real.continuous_sqrt.measurable.comp
    (measurable_coe_nnreal_real.comp measurable_fst)).smul
    (measurable_subtype_coe.comp measurable_snd)

/--
Law generated by:
1. sample squared radius from `radiusSqLaw`,
2. sample direction uniformly from the sphere,
3. set `Z = √S • U`.
-/
def sphericalLaw (d : ℕ) (radiusSqLaw : Distribution NNReal) : Distribution (Vec d) :=
  pushforward (radialReconstruct d) (productLaw radiusSqLaw (sphereUniform d))
    (measurable_radialReconstruct d)

/-- Rotation-invariance predicate for laws on `ℝ^d`. -/
def IsRotationInvariant (d : ℕ) (μ : Distribution (Vec d)) : Prop :=
  ∀ O : (Vec d) ≃ₗᵢ[ℝ] Vec d, pushforward (fun z => O z) μ O.continuous.measurable = μ

/--
**Lemma (Spherical law, rotation-invariance part):**
spherical construction is rotation-invariant.

Technical note: this formal proof works with measure coercions from
probability measures to reuse `Measure.map_prod_map`.
-/
theorem sphericalLaw_rotationInvariant
    (d : ℕ)
    (_hDim : 2 ≤ d)
    (radiusSqLaw : Distribution NNReal) :
    IsRotationInvariant d (sphericalLaw d radiusSqLaw) := by
  intro O
  -- Step 1: establish measurability of every map that appears in `map_map` rewrites.
  have hMeasO : Measurable (fun z : Vec d => O z) := O.continuous.measurable
  have hMeasRadialReconstruct : Measurable (radialReconstruct d) := measurable_radialReconstruct d
  have hMeasRotateSphere : Measurable (rotateSphere O) := measurable_rotateSphere O
  have hMeasRotateProd :
      Measurable (Prod.map id (rotateSphere O) : NNReal × Sphere d → NNReal × Sphere d) :=
    measurable_id.prodMap hMeasRotateSphere
  -- Step 2: pointwise algebra. Rotating `√s • u` equals reconstructing from `(s, O u)`.
  have hPointwiseCommute :
      ((fun z : Vec d => O z) ∘ radialReconstruct d) =
        radialReconstruct d ∘ Prod.map id (rotateSphere O) := by
    funext p
    rcases p with ⟨r, u⟩
    simp [radialReconstruct, rotateSphere, Function.comp]
  -- Step 3: transport the product law through `Prod.map id (rotateSphere O)`.
  -- The first coordinate is unchanged, and the second one is invariant by imported axiom.
  have hProdMap :
      Measure.map
          (Prod.map id (rotateSphere O))
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) =
        ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
    calc
      Measure.map
          (Prod.map id (rotateSphere O))
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)))
          = (Measure.map id (radiusSqLaw : Measure NNReal)).prod
              (Measure.map (rotateSphere O) (sphereUniform d : Measure (Sphere d))) := by
              symm
              exact Measure.map_prod_map
                (radiusSqLaw : Measure NNReal)
                (sphereUniform d : Measure (Sphere d))
                measurable_id hMeasRotateSphere
      _ = (radiusSqLaw : Measure NNReal).prod
            (Measure.map (rotateSphere O) (sphereUniform d : Measure (Sphere d))) := by
            simp [Measure.map_id]
      _ = (radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)) := by
            have hRot :
                Measure.map (rotateSphere O) (sphereUniform d : Measure (Sphere d)) =
                  (sphereUniform d : Measure (Sphere d)) := by
              exact congrArg (fun ν : Distribution (Sphere d) => (ν : Measure (Sphere d)))
                (sphereUniform_rotationInvariant d O)
            simp [hRot]
  -- Step 4: chain the previous identities into equality of pushforward laws.
  apply Subtype.ext
  change
    Measure.map
      (fun z : Vec d => O z)
      (Measure.map
        (radialReconstruct d)
        ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))))
    =
    Measure.map
      (radialReconstruct d)
      ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)))
  calc
    Measure.map
      (fun z : Vec d => O z)
      (Measure.map
        (radialReconstruct d)
        ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))))
        = Measure.map
            ((fun z : Vec d => O z) ∘ radialReconstruct d)
            ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
            rw [Measure.map_map hMeasO hMeasRadialReconstruct]
    _ = Measure.map
          (radialReconstruct d ∘ Prod.map id (rotateSphere O))
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
            rw [hPointwiseCommute]
    _ = Measure.map
          (radialReconstruct d)
          (Measure.map
            (Prod.map id (rotateSphere O))
            ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)))) := by
            rw [← Measure.map_map hMeasRadialReconstruct hMeasRotateProd]
    _ = Measure.map
          (radialReconstruct d)
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
            rw [hProdMap]

/--
**Lemma (header-level identification by squared-radius law).**

If `U` is uniform on the sphere, independent of nonnegative squared-radius variable `S`,
then the law of `Z = √S • U` is exactly the spherical law built from `S`'s law.

This is the theorem-shape needed in the proof plan; proof is deferred for now.
-/
theorem sphericalLaw_determinedByRadius
    (d : ℕ)
    (hDim : 2 ≤ d)
    {Ω : Type _}
    [MeasurableSpace Ω]
    (μ : Distribution Ω)
    (S : Ω → NNReal)
    (U : Ω → Sphere d)
    (hS : Measurable S)
    (hUmeas : Measurable U)
    (hReconstruct : Measurable (fun ω => (Real.sqrt (S ω : ℝ)) • (U ω).1))
    (hU : pushforward U μ hUmeas = sphereUniform d)
    (hIndep : IndepLaw μ S U hS hUmeas) :
    pushforward (fun ω => (Real.sqrt (S ω : ℝ)) • (U ω).1) μ hReconstruct =
      sphericalLaw d (pushforward S μ hS) := by
  -- Deferred: this is the identification theorem required by the proof plan.
  sorry

/-! ## Wristband Equivalence Skeleton -/

/--
**Theorem (Wristband equivalence, forward direction: `Q = γ → P_Q = μ₀`).**

Roadmap:
1. Use Gaussian polar decomposition (imported package).
2. Apply Probability Integral Transform (PIT) to the chi-square radius.
3. Transfer independence through the CDF map.
4. Identify the wristband law as `wristbandUniform`.
-/
theorem wristbandEquivalence_forward
    (d : ℕ)
    (hDim : 2 ≤ d) :
    wristbandLaw d (gaussianNZ d) = wristbandUniform d := by
  have hDim1 : 1 ≤ d := le_trans (by decide : 1 ≤ 2) hDim
  have hDirMeas : Measurable (direction (d := d)) := measurable_direction d
  have hRadMeas : Measurable (radiusSq (d := d)) := measurable_radiusSq d
  have hPairMeas : Measurable (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z)) :=
    hDirMeas.prodMk hRadMeas
  have hCDFMeas : Measurable (chiSqCDFToUnit d) := chiSqCDFToUnit_measurable d
  have hProdMapMeas :
      Measurable (Prod.map id (chiSqCDFToUnit d) : Sphere d × NNReal → Sphere d × UnitInterval) :=
    measurable_id.prodMap hCDFMeas
  have hDir : pushforward (direction (d := d)) (gaussianNZ d) hDirMeas = sphereUniform d := by
    simpa [hDirMeas] using gaussianPolar_direction_uniform d
  have hRad : pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas = chiSqRadiusLaw d := by
    simpa [hRadMeas] using gaussianPolar_radius_chiSq d

  have hJoint :
      pushforward (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z))
        (gaussianNZ d) hPairMeas
      = productLaw
          (pushforward (direction (d := d)) (gaussianNZ d) hDirMeas)
          (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas) :=
    gaussianPolar_independent d

  have hMapJoint :
      pushforward (Prod.map id (chiSqCDFToUnit d))
          (pushforward (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z))
            (gaussianNZ d) hPairMeas)
          hProdMapMeas
      = pushforward (Prod.map id (chiSqCDFToUnit d))
          (productLaw
            (pushforward (direction (d := d)) (gaussianNZ d) hDirMeas)
            (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas))
          hProdMapMeas := by
    rw [hJoint]

  have hMapProd :
      pushforward (Prod.map id (chiSqCDFToUnit d))
          (productLaw
            (pushforward (direction (d := d)) (gaussianNZ d) hDirMeas)
            (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas))
          hProdMapMeas
      = productLaw
          (pushforward (direction (d := d)) (gaussianNZ d) hDirMeas)
          (pushforward (chiSqCDFToUnit d)
            (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas)
            hCDFMeas) := by
    apply Subtype.ext
    change
      Measure.map
          (Prod.map id (chiSqCDFToUnit d))
          (((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d)).prod
            ((pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas : Distribution NNReal) : Measure NNReal))
      =
      (((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d)).prod
        ((pushforward (chiSqCDFToUnit d)
          (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas) hCDFMeas : Distribution UnitInterval) : Measure UnitInterval))
    calc
      Measure.map
          (Prod.map id (chiSqCDFToUnit d))
          (((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d)).prod
            ((pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas : Distribution NNReal) : Measure NNReal))
          = (Measure.map id ((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d))).prod
              (Measure.map (chiSqCDFToUnit d) ((pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas : Distribution NNReal) : Measure NNReal)) := by
              symm
              exact Measure.map_prod_map
                (((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d)))
                (((pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas : Distribution NNReal) : Measure NNReal))
                measurable_id hCDFMeas
      _ =
        (((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d)).prod
          (Measure.map (chiSqCDFToUnit d)
            ((pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas : Distribution NNReal) : Measure NNReal))) := by
            simp [Measure.map_id]
      _ =
        (((pushforward (direction (d := d)) (gaussianNZ d) hDirMeas : Distribution (Sphere d)) : Measure (Sphere d)).prod
          ((pushforward (chiSqCDFToUnit d)
            (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas)
            hCDFMeas : Distribution UnitInterval) : Measure UnitInterval)) := by
            rfl

  have hWristbandAsMap :
      wristbandLaw d (gaussianNZ d)
      = pushforward (Prod.map id (chiSqCDFToUnit d))
          (pushforward (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z))
            (gaussianNZ d) hPairMeas)
          hProdMapMeas := by
    apply Subtype.ext
    change
      Measure.map (wristbandMap d) (gaussianNZ d : Measure (VecNZ d))
      =
      Measure.map
        (Prod.map id (chiSqCDFToUnit d))
        (Measure.map (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z))
          (gaussianNZ d : Measure (VecNZ d)))
    calc
      Measure.map (wristbandMap d) (gaussianNZ d : Measure (VecNZ d))
          = Measure.map
              ((Prod.map id (chiSqCDFToUnit d)) ∘
                (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z)))
              (gaussianNZ d : Measure (VecNZ d)) := by
                rfl
      _ = Measure.map
            (Prod.map id (chiSqCDFToUnit d))
            (Measure.map (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z))
              (gaussianNZ d : Measure (VecNZ d))) := by
              rw [Measure.map_map hProdMapMeas hPairMeas]

  have hZero : ((chiSqCDFToUnit d 0 : UnitInterval) : ℝ) = 0 := by
    rw [chiSqCDFToUnit_eq_pos d hDim1, chiSqCDFToUnitPos]
    change ProbabilityTheory.cdf (chiSqMeasureR d) 0 = 0
    rw [chiSqMeasureR]
    rw [ProbabilityTheory.cdf_gammaMeasure_eq_lintegral (chiSqShape_pos d hDim1) chiSqRate_pos (0 : ℝ)]
    rw [ENNReal.toReal_eq_zero_iff]
    left
    calc
      ∫⁻ x in Set.Iic (0 : ℝ), ProbabilityTheory.gammaPDF (chiSqShape d) chiSqRate x
          = (∫⁻ x in Set.Iio (0 : ℝ), ProbabilityTheory.gammaPDF (chiSqShape d) chiSqRate x) +
              (∫⁻ x in Set.Icc (0 : ℝ) 0, ProbabilityTheory.gammaPDF (chiSqShape d) chiSqRate x) := by
                simpa using
                  (lintegral_Iic_eq_lintegral_Iio_add_Icc
                    (f := ProbabilityTheory.gammaPDF (chiSqShape d) chiSqRate)
                    (hzy := (le_rfl : (0 : ℝ) ≤ 0)))
      _ = 0 + (∫⁻ x in Set.Icc (0 : ℝ) 0, ProbabilityTheory.gammaPDF (chiSqShape d) chiSqRate x) := by
            rw [ProbabilityTheory.lintegral_gammaPDF_of_nonpos
              (a := chiSqShape d)
              (r := chiSqRate)
              (x := (0 : ℝ))
              (hx := le_rfl)]
      _ = 0 + 0 := by
            congr
            exact MeasureTheory.setLIntegral_measure_zero
              (s := Set.Icc (0 : ℝ) 0)
              (f := ProbabilityTheory.gammaPDF (chiSqShape d) chiSqRate)
              (hs' := by simp)
      _ = 0 := by simp

  have hPIT :
      pushforward (chiSqCDFToUnit d) (chiSqRadiusLaw d) hCDFMeas = uniform01 :=
    probabilityIntegralTransform
      (chiSqRadiusLaw d)
      (chiSqCDFToUnit d)
      hCDFMeas
      (chiSqCDFToUnit_isContinuousCDF d hDim1)
      hZero

  calc
    wristbandLaw d (gaussianNZ d)
        = pushforward (Prod.map id (chiSqCDFToUnit d))
            (pushforward (fun z : VecNZ d => (direction (d := d) z, radiusSq (d := d) z))
              (gaussianNZ d) hPairMeas)
            hProdMapMeas := hWristbandAsMap
    _ = pushforward (Prod.map id (chiSqCDFToUnit d))
          (productLaw
            (pushforward (direction (d := d)) (gaussianNZ d) hDirMeas)
            (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas))
          hProdMapMeas := hMapJoint
    _ = productLaw
          (pushforward (direction (d := d)) (gaussianNZ d) hDirMeas)
          (pushforward (chiSqCDFToUnit d)
            (pushforward (radiusSq (d := d)) (gaussianNZ d) hRadMeas)
            hCDFMeas) := hMapProd
    _ = productLaw (sphereUniform d) (pushforward (chiSqCDFToUnit d) (chiSqRadiusLaw d) hCDFMeas) := by
          simp [hDir, hRad]
    _ = productLaw (sphereUniform d) uniform01 := by
          simp [hPIT]
    _ = wristbandUniform d := by
          rfl

/--
**Theorem (Wristband equivalence, backward direction: `P_Q = μ₀ → Q = γ`).**

Roadmap:
1. Read off uniform marginals and independence from `P_Q = μ₀`.
2. Use reverse PIT to recover the chi-square radius law.
3. Apply Spherical law determined by radius lemma.
4. Match Gaussian polar data and conclude `Q = γ`.
-/
theorem wristbandEquivalence_backward
    (d : ℕ)
    (hDim : 2 ≤ d)
    (Q : Distribution (VecNZ d))
    (hUniform : wristbandLaw d Q = wristbandUniform d) :
    Q = gaussianNZ d := by
  -- Deferred until PIT reverse direction is implemented concretely.
  sorry

/--
**Theorem (full equivalence).**

This is the core logical bridge used later by kernel/energy minimization results.
-/
theorem wristbandEquivalence
    (d : ℕ)
    (hDim : 2 ≤ d)
    (Q : Distribution (VecNZ d)) :
    wristbandLaw d Q = wristbandUniform d ↔ Q = gaussianNZ d := by
  constructor
  · intro hUniform
    exact wristbandEquivalence_backward d hDim Q hUniform
  · intro hGaussian
    simpa [hGaussian] using wristbandEquivalence_forward d hDim

end WristbandLossProofs
