import WristbandLossProofs.ImportedFacts

set_option autoImplicit false

noncomputable section

namespace WristbandLossProofs

open MeasureTheory

/-! ## Wristband Construction Primitives -/

/-- The wristband map `Φ(z) = (direction(z), CDF(radiusSq(z)))`. -/
def wristbandMap (d : ℕ) (z : VecNZ d) : Wristband d :=
  (direction (d := d) z, chiSqCDFToUnit d (radiusSq z))

/-- Measurability of the wristband map. -/
lemma measurable_wristbandMap (d : ℕ) : Measurable (wristbandMap d) := by
  refine (measurable_direction d).prodMk ?_
  exact (chiSqCDFToUnit_measurable d).comp (measurable_radiusSq d)

/-- Pushforward wristband law `P_Q = Φ_#Q`. -/
def wristbandLaw (d : ℕ) (Q : Distribution (VecNZ d)) : Distribution (Wristband d) :=
  pushforward (wristbandMap d) Q (measurable_wristbandMap d)

/-! ## Spherical Law Determined by Radius Skeleton -/

/--
Reconstruct a vector from `(squared radius, direction)` by
`(s, u) ↦ √s • u`.
-/
def radialReconstruct (d : ℕ) : NNReal × Sphere d → Vec d
  | (s, u) => (Real.sqrt (s : ℝ)) • u.1

/-- Measurability of the radial reconstruction map. -/
lemma measurable_radialReconstruct (d : ℕ) : Measurable (radialReconstruct d) := by
  change Measurable (fun p : NNReal × Sphere d => Real.sqrt (p.1 : ℝ) • p.2.1)
  exact (Real.continuous_sqrt.measurable.comp
    (measurable_coe_nnreal_real.comp measurable_fst)).smul
    (measurable_subtype_coe.comp measurable_snd)

/--
Law generated by:
1. sample squared radius from `radiusSqLaw`,
2. sample direction uniformly from the sphere,
3. set `Z = √S • U`.
-/
def sphericalLaw (d : ℕ) (radiusSqLaw : Distribution NNReal) : Distribution (Vec d) :=
  pushforward (radialReconstruct d) (productLaw radiusSqLaw (sphereUniform d))
    (measurable_radialReconstruct d)

/-- Rotation-invariance predicate for laws on `ℝ^d`. -/
def IsRotationInvariant (d : ℕ) (μ : Distribution (Vec d)) : Prop :=
  ∀ O : (Vec d) ≃ₗᵢ[ℝ] Vec d, pushforward (fun z => O z) μ O.continuous.measurable = μ

/--
**Lemma (Spherical law, rotation-invariance part):**
spherical construction is rotation-invariant.

Technical note: this formal proof works with measure coercions from
probability measures to reuse `Measure.map_prod_map`.
-/
theorem sphericalLaw_rotationInvariant
    (d : ℕ)
    (_hDim : 2 ≤ d)
    (radiusSqLaw : Distribution NNReal) :
    IsRotationInvariant d (sphericalLaw d radiusSqLaw) := by
  intro O
  -- Step 1: establish measurability of every map that appears in `map_map` rewrites.
  have hMeasO : Measurable (fun z : Vec d => O z) := O.continuous.measurable
  have hMeasRadialReconstruct : Measurable (radialReconstruct d) := measurable_radialReconstruct d
  have hMeasRotateSphere : Measurable (rotateSphere O) := measurable_rotateSphere O
  have hMeasRotateProd :
      Measurable (Prod.map id (rotateSphere O) : NNReal × Sphere d → NNReal × Sphere d) :=
    measurable_id.prodMap hMeasRotateSphere
  -- Step 2: pointwise algebra. Rotating `√s • u` equals reconstructing from `(s, O u)`.
  have hPointwiseCommute :
      ((fun z : Vec d => O z) ∘ radialReconstruct d) =
        radialReconstruct d ∘ Prod.map id (rotateSphere O) := by
    funext p
    rcases p with ⟨r, u⟩
    simp [radialReconstruct, rotateSphere, Function.comp]
  -- Step 3: transport the product law through `Prod.map id (rotateSphere O)`.
  -- The first coordinate is unchanged, and the second one is invariant by imported axiom.
  have hProdMap :
      Measure.map
          (Prod.map id (rotateSphere O))
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) =
        ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
    calc
      Measure.map
          (Prod.map id (rotateSphere O))
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)))
          = (Measure.map id (radiusSqLaw : Measure NNReal)).prod
              (Measure.map (rotateSphere O) (sphereUniform d : Measure (Sphere d))) := by
              symm
              exact Measure.map_prod_map
                (radiusSqLaw : Measure NNReal)
                (sphereUniform d : Measure (Sphere d))
                measurable_id hMeasRotateSphere
      _ = (radiusSqLaw : Measure NNReal).prod
            (Measure.map (rotateSphere O) (sphereUniform d : Measure (Sphere d))) := by
            simp [Measure.map_id]
      _ = (radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)) := by
            have hRot :
                Measure.map (rotateSphere O) (sphereUniform d : Measure (Sphere d)) =
                  (sphereUniform d : Measure (Sphere d)) := by
              exact congrArg (fun ν : Distribution (Sphere d) => (ν : Measure (Sphere d)))
                (sphereUniform_rotationInvariant d O)
            simp [hRot]
  -- Step 4: chain the previous identities into equality of pushforward laws.
  apply Subtype.ext
  change
    Measure.map
      (fun z : Vec d => O z)
      (Measure.map
        (radialReconstruct d)
        ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))))
    =
    Measure.map
      (radialReconstruct d)
      ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)))
  calc
    Measure.map
      (fun z : Vec d => O z)
      (Measure.map
        (radialReconstruct d)
        ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))))
        = Measure.map
            ((fun z : Vec d => O z) ∘ radialReconstruct d)
            ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
            rw [Measure.map_map hMeasO hMeasRadialReconstruct]
    _ = Measure.map
          (radialReconstruct d ∘ Prod.map id (rotateSphere O))
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
            rw [hPointwiseCommute]
    _ = Measure.map
          (radialReconstruct d)
          (Measure.map
            (Prod.map id (rotateSphere O))
            ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d)))) := by
            rw [← Measure.map_map hMeasRadialReconstruct hMeasRotateProd]
    _ = Measure.map
          (radialReconstruct d)
          ((radiusSqLaw : Measure NNReal).prod (sphereUniform d : Measure (Sphere d))) := by
            rw [hProdMap]

/--
**Lemma (header-level identification by squared-radius law).**

If `U` is uniform on the sphere, independent of nonnegative squared-radius variable `S`,
then the law of `Z = √S • U` is exactly the spherical law built from `S`'s law.

This is the theorem-shape needed in the proof plan; proof is deferred for now.
-/
theorem sphericalLaw_determinedByRadius
    (d : ℕ)
    (hDim : 2 ≤ d)
    {Ω : Type _}
    [MeasurableSpace Ω]
    (μ : Distribution Ω)
    (S : Ω → NNReal)
    (U : Ω → Sphere d)
    (hS : Measurable S)
    (hUmeas : Measurable U)
    (hReconstruct : Measurable (fun ω => (Real.sqrt (S ω : ℝ)) • (U ω).1))
    (hU : pushforward U μ hUmeas = sphereUniform d)
    (hIndep : IndepLaw μ S U hS hUmeas) :
    pushforward (fun ω => (Real.sqrt (S ω : ℝ)) • (U ω).1) μ hReconstruct =
      sphericalLaw d (pushforward S μ hS) := by
  -- Deferred: this is the identification theorem required by the proof plan.
  sorry

/-! ## Wristband Equivalence Skeleton -/

/--
**Theorem (Wristband equivalence, forward direction: `Q = γ → P_Q = μ₀`).**

Roadmap:
1. Use Gaussian polar decomposition (imported package).
2. Apply Probability Integral Transform (PIT) to the chi-square radius.
3. Transfer independence through the CDF map.
4. Identify the wristband law as `wristbandUniform`.
-/
theorem wristbandEquivalence_forward
    (d : ℕ)
    (hDim : 2 ≤ d) :
    wristbandLaw d (gaussianNZ d) = wristbandUniform d := by
  -- Deferred until PIT + independence lemmas are concretized.
  sorry

/--
**Theorem (Wristband equivalence, backward direction: `P_Q = μ₀ → Q = γ`).**

Roadmap:
1. Read off uniform marginals and independence from `P_Q = μ₀`.
2. Use reverse PIT to recover the chi-square radius law.
3. Apply Spherical law determined by radius lemma.
4. Match Gaussian polar data and conclude `Q = γ`.
-/
theorem wristbandEquivalence_backward
    (d : ℕ)
    (hDim : 2 ≤ d)
    (Q : Distribution (VecNZ d))
    (hUniform : wristbandLaw d Q = wristbandUniform d) :
    Q = gaussianNZ d := by
  -- Deferred until PIT reverse direction is implemented concretely.
  sorry

/--
**Theorem (full equivalence).**

This is the core logical bridge used later by kernel/energy minimization results.
-/
theorem wristbandEquivalence
    (d : ℕ)
    (hDim : 2 ≤ d)
    (Q : Distribution (VecNZ d)) :
    wristbandLaw d Q = wristbandUniform d ↔ Q = gaussianNZ d := by
  constructor
  · intro hUniform
    exact wristbandEquivalence_backward d hDim Q hUniform
  · intro hGaussian
    simpa [hGaussian] using wristbandEquivalence_forward d hDim

end WristbandLossProofs
