import WristbandLossProofs.Foundations

set_option autoImplicit false

noncomputable section

namespace WristbandLossProofs

open MeasureTheory

/-! ## Wristband Construction Primitives -/

/-- The wristband map `Φ(z) = (direction(z), CDF(radiusSq(z)))`. -/
def wristbandMap (d : ℕ) (z : VecNZ d) : Wristband d :=
  (direction (d := d) z, chiSqCDFToUnit d (radiusSq z))

/-- Pushforward wristband law `P_Q = Φ_#Q`. -/
def wristbandLaw (d : ℕ) (Q : Distribution (VecNZ d)) : Distribution (Wristband d) :=
  pushforward (wristbandMap d) Q

/-! ## Spherical Law Determined by Radius Skeleton -/

/-- Reconstruct a vector from `(radius, direction)` by scalar multiplication. -/
def radialReconstruct (d : ℕ) : NNReal × Sphere d → Vec d
  | (r, u) => (r : ℝ) • u.1

/--
Law generated by:
1. sample radius from `radiusLaw`,
2. sample direction uniformly from the sphere,
3. set `Z = R • U`.
-/
def sphericalLaw (d : ℕ) (radiusLaw : Distribution NNReal) : Distribution (Vec d) :=
  pushforward (radialReconstruct d) (productLaw radiusLaw (sphereUniform d))

/-- Rotation-invariance predicate for laws on `ℝ^d`. -/
def IsRotationInvariant (d : ℕ) (μ : Distribution (Vec d)) : Prop :=
  ∀ O : (Vec d) ≃ₗᵢ[ℝ] Vec d, pushforward (fun z => O z) μ = μ

/--
**Lemma (Spherical law, rotation-invariance part):**
spherical construction is rotation-invariant.
-/
theorem sphericalLaw_rotationInvariant
    (d : ℕ)
    (radiusLaw : Distribution NNReal) :
    IsRotationInvariant d (sphericalLaw d radiusLaw) := by
  intro O
  -- Tutorial roadmap:
  -- 1. Show `O (r • u) = r • (O u)` pointwise.
  -- 2. Push this identity through the distribution construction.
  -- 3. Use `sphereUniform_rotationInvariant`.
  -- 4. Conclude the final law is unchanged by `O`.
  sorry

/--
**Lemma (Spherical law, radius-identification part):**
once direction is uniform/independent,
the law of `Z = R•U` is fully determined by the law of `R`.
-/
theorem sphericalLaw_determinedByRadius
    (d : ℕ)
    {radiusLaw₁ radiusLaw₂ : Distribution NNReal}
    (hRadius : radiusLaw₁ = radiusLaw₂) :
    sphericalLaw d radiusLaw₁ = sphericalLaw d radiusLaw₂ := by
  simp [sphericalLaw, hRadius]

/-! ## Wristband Equivalence Skeleton -/

/--
**Theorem (Wristband equivalence, forward direction: `Q = γ → P_Q = μ₀`).**

Roadmap:
1. Use Gaussian polar decomposition (imported package).
2. Apply Probability Integral Transform (PIT) to the chi-square radius.
3. Transfer independence through the CDF map.
4. Identify the wristband law as `wristbandUniform`.
-/
theorem wristbandEquivalence_forward (d : ℕ) :
    wristbandLaw d (gaussianNZ d) = wristbandUniform d := by
  -- Deferred until PIT + independence lemmas are concretized.
  sorry

/--
**Theorem (Wristband equivalence, backward direction: `P_Q = μ₀ → Q = γ`).**

Roadmap:
1. Read off uniform marginals and independence from `P_Q = μ₀`.
2. Use reverse PIT to recover the chi-square radius law.
3. Apply Spherical law determined by radius lemma.
4. Match Gaussian polar data and conclude `Q = γ`.
-/
theorem wristbandEquivalence_backward
    (d : ℕ)
    (Q : Distribution (VecNZ d))
    (hUniform : wristbandLaw d Q = wristbandUniform d) :
    Q = gaussianNZ d := by
  -- Deferred until PIT reverse direction is implemented concretely.
  sorry

/--
**Theorem (full equivalence).**

This is the core logical bridge used later by kernel/energy minimization results.
-/
theorem wristbandEquivalence
    (d : ℕ)
    (Q : Distribution (VecNZ d)) :
    wristbandLaw d Q = wristbandUniform d ↔ Q = gaussianNZ d := by
  constructor
  · intro hUniform
    exact wristbandEquivalence_backward d Q hUniform
  · intro hGaussian
    simpa [hGaussian] using wristbandEquivalence_forward d

end WristbandLossProofs
